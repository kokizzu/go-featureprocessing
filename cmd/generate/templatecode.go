package main

const templateCode = `
// Code generated by go-featureprocessing DO NOT EDIT

package {{$.PackageName}}

import (
	fp "github.com/nikolaydubina/go-featureprocessing/transformers"
)

// {{$.StructName}}FeatureTransformer is a feature processor for {{$.StructName}}.
// It was automatically generated by go-featureprocessing tool.
type {{$.StructName}}FeatureTransformer struct {
	{{range $i, $tr := $.Fields}}{{$tr.Name}} fp.{{$tr.Transformer}}
	{{end}}
}

// Fit fits transformer for each field
func (e *{{$.StructName}}FeatureTransformer) Fit(s []{{$.StructName}}) {
	if e == nil || len(s) == 0 {
		return
	}

	{{if $.HasNumericalTransformers}}dataNum := make([]float64, len(s)){{end}}
	{{if $.HasStringTransformers}}dataStr := make([]string, len(s)){{end}}

	{{range $i, $tr := $.Fields}}

	for i, v := range s {
		{{if $tr.NumericalInput }}dataNum[i] = float64(v.{{$tr.Name}}){{else}}dataStr[i] = string(v.{{$tr.Name}}){{end}}
	}

	e.{{$tr.Name}}.Fit({{if $tr.NumericalInput }}dataNum{{else}}dataStr{{end}})
	
	{{end}}
}

// Transform transforms struct into feature vector accordingly to transformers
func (e *{{$.StructName}}FeatureTransformer) Transform(s *{{$.StructName}}) []float64 {
	if s == nil || e == nil {
		return nil
	}

	features := make([]float64, 0, e.GetNumFeatures())

	return e.transform(features, s)
}

// transform is utilizing mid-stack inliner, the idea is that publicly exported function will be inlined, 
// meaning final features slice will not escape to heap
func (e *{{$.StructName}}FeatureTransformer) transform(features []float64, s *{{$.StructName}}) []float64 {
	{{range $i, $tr := $.Fields}}features = append(features, e.{{$tr.Name}}.Transform( {{if $tr.NumericalInput }}float64{{else}}string{{end}}( s.{{$tr.Name}} ) ){{if $tr.Expanding}}...{{end}})
	{{end}}
	return features
}

// GetNumFeatures returns number of features in output feature vector
func (e *{{$.StructName}}FeatureTransformer) GetNumFeatures() int {
	if e == nil {
		return 0
	}

	count := {{$.NumFieldsFlat}}
	{{range $i, $tr := $.Fields}}{{if $tr.Expanding}}count += e.{{$tr.Name}}.NumFeatures(){{end}}
	{{end}}
	return count
}
`
