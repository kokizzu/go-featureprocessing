// Code generated by go-featureprocessing DO NOT EDIT

package examplemodule

import (
	fp "github.com/nikolaydubina/go-featureprocessing/transformers"
)

// AllTransformersFeatureTransformer is a feature processor for AllTransformers.
// It was automatically generated by go-featureprocessing tool.
type AllTransformersFeatureTransformer struct {
	Name0 fp.Identity         `json:"Name0_identity"`
	Name1 fp.MinMaxScaler     `json:"Name1_minmax"`
	Name2 fp.MaxAbsScaler     `json:"Name2_maxabs"`
	Name3 fp.StandardScaler   `json:"Name3_standard"`
	Name4 fp.QuantileScaler   `json:"Name4_quantile"`
	Name5 fp.OneHotEncoder    `json:"Name5_onehot"`
	Name6 fp.OrdinalEncoder   `json:"Name6_ordinal"`
	Name7 fp.KBinsDiscretizer `json:"Name7_kbins"`
	Name8 fp.CountVectorizer  `json:"Name8_countvectorizer"`
	Name9 fp.TFIDFVectorizer  `json:"Name9_tfidf"`
}

// Fit fits transformer for each field
func (e *AllTransformersFeatureTransformer) Fit(s []AllTransformers) {
	if e == nil || len(s) == 0 {
		return
	}

	dataNum := make([]float64, len(s))
	dataStr := make([]string, len(s))

	for i, v := range s {
		dataNum[i] = float64(v.Name0)
	}

	e.Name0.Fit(dataNum)

	for i, v := range s {
		dataNum[i] = float64(v.Name1)
	}

	e.Name1.Fit(dataNum)

	for i, v := range s {
		dataNum[i] = float64(v.Name2)
	}

	e.Name2.Fit(dataNum)

	for i, v := range s {
		dataNum[i] = float64(v.Name3)
	}

	e.Name3.Fit(dataNum)

	for i, v := range s {
		dataNum[i] = float64(v.Name4)
	}

	e.Name4.Fit(dataNum)

	for i, v := range s {
		dataStr[i] = string(v.Name5)
	}

	e.Name5.Fit(dataStr)

	for i, v := range s {
		dataStr[i] = string(v.Name6)
	}

	e.Name6.Fit(dataStr)

	for i, v := range s {
		dataNum[i] = float64(v.Name7)
	}

	e.Name7.Fit(dataNum)

	for i, v := range s {
		dataStr[i] = string(v.Name8)
	}

	e.Name8.Fit(dataStr)

	for i, v := range s {
		dataStr[i] = string(v.Name9)
	}

	e.Name9.Fit(dataStr)

}

// Transform transforms struct into feature vector accordingly to transformers
func (e *AllTransformersFeatureTransformer) Transform(s *AllTransformers) []float64 {
	if s == nil || e == nil {
		return nil
	}

	features := make([]float64, e.GetNumFeatures())
	e.TransformInplace(features, s)
	return features
}

// TransformInplace transforms struct into feature vector accordingly to transformers, and does so inplace
func (e *AllTransformersFeatureTransformer) TransformInplace(dst []float64, s *AllTransformers) {
	if s == nil || e == nil || len(dst) != e.GetNumFeatures() {
		return
	}

	idx := 0

	dst[idx] = e.Name0.Transform(float64(s.Name0))
	idx++

	dst[idx] = e.Name1.Transform(float64(s.Name1))
	idx++

	dst[idx] = e.Name2.Transform(float64(s.Name2))
	idx++

	dst[idx] = e.Name3.Transform(float64(s.Name3))
	idx++

	dst[idx] = e.Name4.Transform(float64(s.Name4))
	idx++

	e.Name5.TransformInplace(dst[idx:idx+e.Name5.NumFeatures()], s.Name5)
	idx += e.Name5.NumFeatures()

	dst[idx] = e.Name6.Transform(string(s.Name6))
	idx++

	dst[idx] = e.Name7.Transform(float64(s.Name7))
	idx++

	e.Name8.TransformInplace(dst[idx:idx+e.Name8.NumFeatures()], s.Name8)
	idx += e.Name8.NumFeatures()

	e.Name9.TransformInplace(dst[idx:idx+e.Name9.NumFeatures()], s.Name9)
	idx += e.Name9.NumFeatures()

	return
}

// GetNumFeatures returns number of features in output feature vector
func (e *AllTransformersFeatureTransformer) GetNumFeatures() int {
	if e == nil {
		return 0
	}

	count := 7

	count += e.Name5.NumFeatures()

	count += e.Name8.NumFeatures()
	count += e.Name9.NumFeatures()

	return count
}

// FeatureNames provides names of features that match output of transform
func (e *AllTransformersFeatureTransformer) FeatureNames() []string {
	if e == nil {
		return nil
	}

	idx := 0
	names := make([]string, e.GetNumFeatures())

	names[idx] = "Name0"
	idx++

	names[idx] = "Name1"
	idx++

	names[idx] = "Name2"
	idx++

	names[idx] = "Name3"
	idx++

	names[idx] = "Name4"
	idx++

	for _, w := range e.Name5.FeatureNames() {
		names[idx] = "Name5_" + w
		idx++
	}

	names[idx] = "Name6"
	idx++

	names[idx] = "Name7"
	idx++

	for _, w := range e.Name8.FeatureNames() {
		names[idx] = "Name8_" + w
		idx++
	}

	for _, w := range e.Name9.FeatureNames() {
		names[idx] = "Name9_" + w
		idx++
	}

	return names
}
