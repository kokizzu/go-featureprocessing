// Code generated by go-featureprocessing DO NOT EDIT

package examplemodule

import (
	fp "github.com/nikolaydubina/go-featureprocessing/transformers"
)

// WeirdTagsFeatureTransformer is a feature processor for WeirdTags.
// It was automatically generated by go-featureprocessing tool.
type WeirdTagsFeatureTransformer struct {
	OnlyFeature     fp.MinMaxScaler
	FeatureNotFirst fp.MaxAbsScaler
	FirstFeature    fp.OneHotEncoder
	Multiline       fp.MaxAbsScaler
}

// Fit fits transformer for each field
func (e *WeirdTagsFeatureTransformer) Fit(s []WeirdTags) {
	if e == nil || len(s) == 0 {
		return
	}

	dataNum := make([]float64, len(s))
	dataStr := make([]string, len(s))

	for i, v := range s {
		dataNum[i] = float64(v.OnlyFeature)
	}

	e.OnlyFeature.Fit(dataNum)

	for i, v := range s {
		dataNum[i] = float64(v.FeatureNotFirst)
	}

	e.FeatureNotFirst.Fit(dataNum)

	for i, v := range s {
		dataStr[i] = string(v.FirstFeature)
	}

	e.FirstFeature.Fit(dataStr)

	for i, v := range s {
		dataNum[i] = float64(v.Multiline)
	}

	e.Multiline.Fit(dataNum)

}

// Transform transforms struct into feature vector accordingly to transformers
func (e *WeirdTagsFeatureTransformer) Transform(s *WeirdTags) []float64 {
	if s == nil || e == nil {
		return nil
	}

	features := make([]float64, 0, e.GetNumFeatures())

	return e.transform(features, s)
}

// transform is utilizing mid-stack inliner, the idea is that publicly exported function will be inlined,
// meaning final features slice will not escape to heap
func (e *WeirdTagsFeatureTransformer) transform(features []float64, s *WeirdTags) []float64 {
	features = append(features, e.OnlyFeature.Transform(float64(s.OnlyFeature)))
	features = append(features, e.FeatureNotFirst.Transform(float64(s.FeatureNotFirst)))
	features = append(features, e.FirstFeature.Transform(string(s.FirstFeature))...)
	features = append(features, e.Multiline.Transform(float64(s.Multiline)))

	return features
}

// GetNumFeatures returns number of features in output feature vector
func (e *WeirdTagsFeatureTransformer) GetNumFeatures() int {
	if e == nil {
		return 0
	}

	count := 3

	count += e.FirstFeature.NumFeatures()

	return count
}
